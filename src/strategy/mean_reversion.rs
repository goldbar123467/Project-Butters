//! Mean Reversion Strategy
//!
//! Core trading strategy that uses z-score gating to identify
//! mean reversion opportunities in price data.
//!
//! Entry Logic:
//! - LONG when z_score < -z_threshold (oversold)
//! - SHORT when z_score > +z_threshold (overbought)
//!
//! Exit Logic:
//! - Exit LONG when z_score > +z_exit_threshold OR take_profit OR stop_loss OR time_stop
//! - Exit SHORT when z_score < -z_exit_threshold OR take_profit OR stop_loss OR time_stop

use std::time::{Duration, Instant};

use crate::ports::strategy::{StrategyPort, StrategyError, Signal, IndicatorValues};
use crate::strategy::params::StrategyConfig;
use crate::strategy::zscore_gate::{ZScoreGate, ZScoreResult};

/// Trading action generated by the strategy
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TradeAction {
    /// Enter a long position
    EnterLong,
    /// Enter a short position
    EnterShort,
    /// Exit current position
    Exit,
    /// Hold current position / no action
    Hold,
}

/// Position state tracked by the strategy
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PositionState {
    /// No open position
    Flat,
    /// Long position open
    Long { entry_price: f64 },
    /// Short position open
    Short { entry_price: f64 },
}

/// Mean reversion strategy implementation
#[derive(Debug)]
pub struct MeanReversionStrategy {
    /// Strategy configuration
    config: StrategyConfig,
    /// Z-score calculation gate
    zscore_gate: ZScoreGate,
    /// Current position state
    position: PositionState,
    /// Last trade timestamp for cooldown
    last_trade_time: Option<Instant>,
    /// Position entry timestamp for time-based exit
    entry_time: Option<Instant>,
    /// Daily trade counter
    daily_trades: u32,
    /// Daily P&L tracking
    daily_pnl: f64,
}

impl MeanReversionStrategy {
    /// Create a new mean reversion strategy
    pub fn new(config: StrategyConfig) -> Self {
        let zscore_gate = ZScoreGate::new(config.clone());
        Self {
            config,
            zscore_gate,
            position: PositionState::Flat,
            last_trade_time: None,
            entry_time: None,
            daily_trades: 0,
            daily_pnl: 0.0,
        }
    }

    /// Update strategy with new price and get trade action
    /// NOTE: This only signals the action - call confirm_trade() after successful execution
    pub fn update(&mut self, price: f64) -> Option<TradeAction> {
        // Update z-score gate
        let zscore_result = self.zscore_gate.update(price)?;

        // Check if we're in cooldown (but NOT for Exit - always allow exit attempts)
        if self.is_in_cooldown() && !matches!(self.position, PositionState::Long { .. } | PositionState::Short { .. }) {
            return Some(TradeAction::Hold);
        }

        // Check risk limits (but NOT for Exit - always allow exit attempts)
        if !self.check_risk_limits() && matches!(self.position, PositionState::Flat) {
            return Some(TradeAction::Hold);
        }

        // Generate action based on current position and z-score
        let action = self.evaluate_action(&zscore_result, price);

        // NOTE: State is NOT updated here - orchestrator must call confirm_trade() after success
        Some(action)
    }

    /// Confirm a trade was successfully executed - updates internal state
    /// Call this ONLY after the on-chain transaction confirms
    pub fn confirm_trade(&mut self, action: TradeAction, price: f64) {
        self.on_trade_executed(action, price);
    }

    /// Evaluate what action to take based on current state
    fn evaluate_action(&self, zscore: &ZScoreResult, current_price: f64) -> TradeAction {
        match self.position {
            PositionState::Flat => {
                // Look for entry signals
                if zscore.is_oversold(self.config.z_threshold) {
                    TradeAction::EnterLong
                } else if zscore.is_overbought(self.config.z_threshold) {
                    TradeAction::EnterShort
                } else {
                    TradeAction::Hold
                }
            }
            PositionState::Long { entry_price } => {
                // Check exit conditions for long
                let pnl_pct = (current_price - entry_price) / entry_price * 100.0;

                // Check time-based exit first
                if let Some(entry_time) = self.entry_time {
                    let hours_elapsed = entry_time.elapsed().as_secs_f64() / 3600.0;
                    if hours_elapsed >= self.config.risk.time_stop_hours {
                        return TradeAction::Exit; // Time stop
                    }
                }

                if pnl_pct >= self.config.risk.take_profit_pct {
                    TradeAction::Exit // Take profit
                } else if pnl_pct <= -self.config.risk.stop_loss_pct {
                    TradeAction::Exit // Stop loss
                } else if zscore.is_overbought(self.config.z_exit_threshold) {
                    TradeAction::Exit // Mean reversion exit (z-score crossed above exit threshold)
                } else {
                    TradeAction::Hold
                }
            }
            PositionState::Short { entry_price } => {
                // Check exit conditions for short
                let pnl_pct = (entry_price - current_price) / entry_price * 100.0;

                // Check time-based exit first
                if let Some(entry_time) = self.entry_time {
                    let hours_elapsed = entry_time.elapsed().as_secs_f64() / 3600.0;
                    if hours_elapsed >= self.config.risk.time_stop_hours {
                        return TradeAction::Exit; // Time stop
                    }
                }

                if pnl_pct >= self.config.risk.take_profit_pct {
                    TradeAction::Exit // Take profit
                } else if pnl_pct <= -self.config.risk.stop_loss_pct {
                    TradeAction::Exit // Stop loss
                } else if zscore.is_oversold(self.config.z_exit_threshold) {
                    TradeAction::Exit // Mean reversion exit (z-score crossed below exit threshold)
                } else {
                    TradeAction::Hold
                }
            }
        }
    }

    /// Handle trade execution updates
    fn on_trade_executed(&mut self, action: TradeAction, price: f64) {
        match action {
            TradeAction::EnterLong => {
                self.position = PositionState::Long { entry_price: price };
                self.last_trade_time = Some(Instant::now());
                self.entry_time = Some(Instant::now());
                self.daily_trades += 1;
            }
            TradeAction::EnterShort => {
                self.position = PositionState::Short { entry_price: price };
                self.last_trade_time = Some(Instant::now());
                self.entry_time = Some(Instant::now());
                self.daily_trades += 1;
            }
            TradeAction::Exit => {
                // Calculate and track P&L
                let pnl = match self.position {
                    PositionState::Long { entry_price } => {
                        (price - entry_price) / entry_price * 100.0
                    }
                    PositionState::Short { entry_price } => {
                        (entry_price - price) / entry_price * 100.0
                    }
                    PositionState::Flat => 0.0,
                };
                self.daily_pnl += pnl;
                self.position = PositionState::Flat;
                self.last_trade_time = Some(Instant::now());
                self.entry_time = None;
            }
            TradeAction::Hold => {}
        }
    }

    /// Check if strategy is in cooldown period
    fn is_in_cooldown(&self) -> bool {
        if let Some(last_trade) = self.last_trade_time {
            let cooldown = Duration::from_secs(self.config.cooldown_seconds);
            last_trade.elapsed() < cooldown
        } else {
            false
        }
    }

    /// Check if risk limits allow trading
    fn check_risk_limits(&self) -> bool {
        // Check daily trade limit
        if self.daily_trades >= self.config.risk.max_daily_trades {
            return false;
        }

        // Check daily loss limit
        if self.daily_pnl <= -self.config.risk.max_daily_loss_pct {
            return false;
        }

        true
    }

    /// Get current position state
    pub fn position(&self) -> PositionState {
        self.position
    }

    /// Get current z-score if available
    pub fn current_zscore(&self) -> Option<ZScoreResult> {
        self.zscore_gate.calculate()
    }

    /// Check if strategy is ready (has enough data)
    pub fn is_ready(&self) -> bool {
        self.zscore_gate.is_ready()
    }

    /// Reset strategy state (for new trading session)
    pub fn reset(&mut self) {
        self.zscore_gate.reset();
        self.position = PositionState::Flat;
        self.last_trade_time = None;
        self.entry_time = None;
        self.daily_trades = 0;
        self.daily_pnl = 0.0;
    }

    /// Reset daily counters (call at start of each trading day)
    pub fn reset_daily(&mut self) {
        self.daily_trades = 0;
        self.daily_pnl = 0.0;
    }

    /// Get daily trade count
    pub fn daily_trade_count(&self) -> u32 {
        self.daily_trades
    }

    /// Get daily P&L percentage
    pub fn daily_pnl_pct(&self) -> f64 {
        self.daily_pnl
    }
}

impl StrategyPort for MeanReversionStrategy {
    fn generate_signals(&mut self, data: &[f64]) -> Result<Vec<Signal>, StrategyError> {
        if data.is_empty() {
            return Err(StrategyError::InsufficientData(1, 0));
        }

        let mut signals = Vec::new();

        for &price in data {
            if let Some(action) = self.update(price) {
                let signal = match action {
                    TradeAction::EnterLong => Signal::StrongBuy,
                    TradeAction::EnterShort => Signal::StrongSell,
                    TradeAction::Exit => {
                        match self.position {
                            PositionState::Long { .. } => Signal::Sell,
                            PositionState::Short { .. } => Signal::Buy,
                            PositionState::Flat => Signal::Hold,
                        }
                    }
                    TradeAction::Hold => Signal::Hold,
                };
                signals.push(signal);
            } else {
                signals.push(Signal::Hold);
            }
        }

        Ok(signals)
    }

    fn calculate_indicators(&mut self, data: &[f64]) -> Result<IndicatorValues, StrategyError> {
        if data.len() < self.config.lookback_period {
            return Err(StrategyError::InsufficientData(
                self.config.lookback_period,
                data.len(),
            ));
        }

        // Feed data into zscore gate
        self.zscore_gate.reset();
        for &price in data {
            self.zscore_gate.update(price);
        }

        let zscore = self.zscore_gate.calculate()
            .ok_or_else(|| StrategyError::CalculationError("Failed to calculate z-score".into()))?;

        Ok(IndicatorValues {
            rsi: None,
            macd: None,
            macd_signal: None,
            macd_histogram: None,
            sma: Some(zscore.mean),
            ema: None,
        })
    }

    fn validate_params(&self) -> Result<(), StrategyError> {
        self.config.validate()
            .map_err(|e| StrategyError::ConfigurationError(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_strategy() -> MeanReversionStrategy {
        let config = StrategyConfig {
            lookback_period: 10,
            z_threshold: 2.0,
            cooldown_seconds: 0, // No cooldown for tests
            ..Default::default()
        };
        MeanReversionStrategy::new(config)
    }

    #[test]
    fn test_strategy_creation() {
        let strategy = create_test_strategy();
        assert_eq!(strategy.position(), PositionState::Flat);
        assert!(!strategy.is_ready());
    }

    #[test]
    fn test_strategy_warmup() {
        let mut strategy = create_test_strategy();

        // Not ready before warmup
        for i in 1..10 {
            let action = strategy.update(100.0 + i as f64);
            assert!(action.is_none() || action == Some(TradeAction::Hold));
        }

        // Ready after warmup
        strategy.update(110.0);
        assert!(strategy.is_ready());
    }

    #[test]
    fn test_long_entry_on_oversold() {
        let mut strategy = create_test_strategy();

        // Fill with stable prices
        for _ in 0..10 {
            strategy.update(100.0);
        }

        // Sudden drop should trigger oversold
        let action = strategy.update(85.0);

        // Should either be EnterLong or Hold depending on z-score
        assert!(action.is_some());
    }

    #[test]
    fn test_exit_on_take_profit() {
        let mut strategy = create_test_strategy();

        // Fill buffer and force a long position
        for _ in 0..10 {
            strategy.update(100.0);
        }

        // Manually set position for test
        strategy.position = PositionState::Long { entry_price: 100.0 };

        // Price rises 2% (above 1.5% take profit)
        let action = strategy.update(102.0);
        assert_eq!(action, Some(TradeAction::Exit));
    }

    #[test]
    fn test_exit_on_stop_loss() {
        let mut strategy = create_test_strategy();

        // Fill buffer
        for _ in 0..10 {
            strategy.update(100.0);
        }

        // Manually set position for test
        strategy.position = PositionState::Long { entry_price: 100.0 };

        // Price drops 3% (below -2% stop loss)
        let action = strategy.update(97.0);
        assert_eq!(action, Some(TradeAction::Exit));
    }

    #[test]
    fn test_daily_trade_limit() {
        let mut strategy = create_test_strategy();
        strategy.daily_trades = 10; // At limit

        // Fill buffer
        for _ in 0..10 {
            strategy.update(100.0);
        }

        // Should hold due to trade limit
        let action = strategy.update(85.0);
        assert_eq!(action, Some(TradeAction::Hold));
    }

    #[test]
    fn test_daily_loss_limit() {
        let mut strategy = create_test_strategy();
        strategy.daily_pnl = -4.0; // Beyond -3% limit

        // Fill buffer
        for _ in 0..10 {
            strategy.update(100.0);
        }

        // Should hold due to loss limit
        let action = strategy.update(85.0);
        assert_eq!(action, Some(TradeAction::Hold));
    }

    #[test]
    fn test_reset() {
        let mut strategy = create_test_strategy();

        // Warm up and set some state
        for _ in 0..10 {
            strategy.update(100.0);
        }
        strategy.daily_trades = 5;
        strategy.daily_pnl = -1.0;

        strategy.reset();

        assert!(!strategy.is_ready());
        assert_eq!(strategy.position(), PositionState::Flat);
        assert_eq!(strategy.daily_trade_count(), 0);
        assert_eq!(strategy.daily_pnl_pct(), 0.0);
    }

    #[test]
    fn test_strategy_port_generate_signals() {
        let mut strategy = create_test_strategy();

        // Test with sufficient data
        let data: Vec<f64> = (0..20).map(|i| 100.0 + (i as f64) * 0.1).collect();
        let signals = strategy.generate_signals(&data);
        assert!(signals.is_ok());
        assert_eq!(signals.unwrap().len(), 20);
    }

    #[test]
    fn test_strategy_port_insufficient_data() {
        let mut strategy = create_test_strategy();

        let result = strategy.generate_signals(&[]);
        assert!(matches!(result, Err(StrategyError::InsufficientData(_, _))));
    }

    #[test]
    fn test_strategy_port_calculate_indicators() {
        let mut strategy = create_test_strategy();

        let data: Vec<f64> = (0..15).map(|i| 100.0 + i as f64).collect();
        let indicators = strategy.calculate_indicators(&data);

        assert!(indicators.is_ok());
        let ind = indicators.unwrap();
        assert!(ind.sma.is_some());
    }

    #[test]
    fn test_validate_params() {
        let strategy = create_test_strategy();
        assert!(strategy.validate_params().is_ok());
    }
}
